{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"radio-galaxy-classifier","text":"<p>This is a template repository for Python projects that use uv for their dependency management.</p>"},{"location":"modules/","title":"Modules","text":"<p>A collection of utility functions for data manipulation.</p> <p>This module contains a collection of utility functions for astronomical data manipulation.</p>"},{"location":"modules/#rgc.utils.data.catalog_quest","title":"<code>catalog_quest(name, service='Vizier')</code>","text":"<p>Fetch a catalog from a given astronomical service e.g. VizieR, Simbad.</p> <p>:param name: The name of the catalog to be fetched. :type name: str</p> <p>:param service: The name of the astronomical service to be used. :type service: str</p> <p>:return: A pandas DataFrame containing the fetched catalog. :rtype: pd.DataFrame</p> <p>:raises _UnsupportedServiceError: If an unsupported service is provided.</p> Source code in <code>rgc/utils/data.py</code> <pre><code>def catalog_quest(name: str, service: str = \"Vizier\") -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch a catalog from a given astronomical service e.g. VizieR, Simbad.\n\n    :param name: The name of the catalog to be fetched.\n    :type name: str\n\n    :param service: The name of the astronomical service to be used.\n    :type service: str\n\n    :return: A pandas DataFrame containing the fetched catalog.\n    :rtype: pd.DataFrame\n\n    :raises _UnsupportedServiceError: If an unsupported service is provided.\n    \"\"\"\n    if service == \"Vizier\":\n        Vizier.ROW_LIMIT = -1\n        catalog = Vizier.get_catalogs(name)\n        return cast(pd.DataFrame, catalog[0].to_pandas())\n    else:\n        raise _UnsupportedServiceError()\n</code></pre>"},{"location":"modules/#rgc.utils.data.celestial_capture","title":"<code>celestial_capture(survey, ra, dec, filename)</code>","text":"<p>Capture a celestial image using the SkyView service.</p> <p>:param survey: The name of the survey to be used e.g. 'VLA FIRST (1.4 GHz)'. :type survey: str</p> <p>:param ra: The right ascension of the celestial object. :type ra: Skycoord</p> <p>:param dec: The declination of the celestial object. :type dec: Skycoord</p> <p>:param filename: The name of the file to save the image. :type filename: str</p> Source code in <code>rgc/utils/data.py</code> <pre><code>def celestial_capture(survey: str, ra: float, dec: float, filename: str) -&gt; None:\n    \"\"\"\n    Capture a celestial image using the SkyView service.\n\n    :param survey: The name of the survey to be used e.g. 'VLA FIRST (1.4 GHz)'.\n    :type survey: str\n\n    :param ra: The right ascension of the celestial object.\n    :type ra: Skycoord\n\n    :param dec: The declination of the celestial object.\n    :type dec: Skycoord\n\n    :param filename: The name of the file to save the image.\n    :type filename: str\n    \"\"\"\n    image = SkyView.get_images(position=f\"{ra}, {dec}\", survey=survey, coordinates=\"J2000\", pixels=(150, 150))[0]\n\n    comment = str(image[0].header[\"COMMENT\"])\n    comment = comment.replace(\"\\n\", \" \")\n    comment = comment.replace(\"\\t\", \" \")\n\n    image[0].header.remove(\"comment\", comment, True)\n    image[0].header.add_comment(comment)\n\n    folder_path = Path(filename).parent\n    Path(folder_path).mkdir(parents=True, exist_ok=True)\n    image.writeto(filename, overwrite=True)\n</code></pre>"},{"location":"modules/#rgc.utils.data.celestial_capture_bulk","title":"<code>celestial_capture_bulk(catalog, survey, img_dir, classes=None, cls_col=None)</code>","text":"<p>Capture celestial images for a catalog of celestial objects.</p> <p>:param catalog: A pandas DataFrame containing the catalog of celestial objects. :type catalog: pd.DataFrame</p> <p>:param survey: The name of the survey to be used e.g. 'VLA FIRST (1.4 GHz)'. :type survey: str</p> <p>:param img_dir: The path to the directory to save the images. :type img_dir: str</p> <p>:param classes: A dictionary containing the classes of the celestial objects. :type classes: dict</p> <p>:param cls_col: The name of the column containing the class labels.</p> <p>:raises _InvalidCoordinatesError: If coordinates are invalid.</p> Source code in <code>rgc/utils/data.py</code> <pre><code>def celestial_capture_bulk(\n    catalog: pd.DataFrame, survey: str, img_dir: str, classes: Optional[dict] = None, cls_col: Optional[str] = None\n) -&gt; None:\n    \"\"\"\n    Capture celestial images for a catalog of celestial objects.\n\n    :param catalog: A pandas DataFrame containing the catalog of celestial objects.\n    :type catalog: pd.DataFrame\n\n    :param survey: The name of the survey to be used e.g. 'VLA FIRST (1.4 GHz)'.\n    :type survey: str\n\n    :param img_dir: The path to the directory to save the images.\n    :type img_dir: str\n\n    :param classes: A dictionary containing the classes of the celestial objects.\n    :type classes: dict\n\n    :param cls_col: The name of the column containing the class labels.\n\n    :raises _InvalidCoordinatesError: If coordinates are invalid.\n    \"\"\"\n    failed = pd.DataFrame(columns=catalog.columns)\n    for _, entry in catalog.iterrows():\n        try:\n            tag = celestial_tag(entry)\n            coordinate = SkyCoord(tag, unit=(u.hourangle, u.deg))\n\n            right_ascension = coordinate.ra.deg\n            declination = coordinate.dec.deg\n\n            label = _get_class_labels(entry, classes, cls_col) if classes is not None and cls_col is not None else \"\"\n\n            if \"filename\" in catalog.columns:\n                filename = f'{img_dir}/{label}_{entry[\"filename\"]}.fits'\n            else:\n                filename = f\"{img_dir}/{label}_{tag}.fits\"\n\n            celestial_capture(survey, right_ascension, declination, filename)\n        except Exception as err:\n            series = entry.to_frame().T\n            failed = pd.concat([failed, series], ignore_index=True)\n            print(f\"Failed to capture image. {err}\")\n</code></pre>"},{"location":"modules/#rgc.utils.data.celestial_tag","title":"<code>celestial_tag(entry)</code>","text":"<p>Generate a name tag for a celestial object based on its coordinates.</p> <p>:param entry: A pandas Series entry of the catalog. :type entry: pd.Series</p> <p>:return: A string containing the name tag. :rtype: str</p> <p>:raises _NoValidCelestialCoordinatesError: If no valid celestial coordinates are found in the entry.</p> Source code in <code>rgc/utils/data.py</code> <pre><code>def celestial_tag(entry: pd.Series) -&gt; str:\n    \"\"\"\n    Generate a name tag for a celestial object based on its coordinates.\n\n    :param entry: A pandas Series entry of the catalog.\n    :type entry: pd.Series\n\n    :return: A string containing the name tag.\n    :rtype: str\n\n    :raises _NoValidCelestialCoordinatesError: If no valid celestial coordinates are found in the entry.\n    \"\"\"\n\n    def format_dec(dec: str) -&gt; str:\n        sign = \"+\" if float(dec.replace(\" \", \"\")) &gt; 0 else \"\"\n        return f\"{sign}{dec}\"\n\n    if {\"RAJ2000\", \"DEJ2000\"}.issubset(entry.index):\n        ra, dec = entry[\"RAJ2000\"], entry[\"DEJ2000\"]\n    elif {\"RA\", \"DEC\"}.issubset(entry.index):\n        ra, dec = entry[\"RA\"], entry[\"DEC\"]\n    elif \"filename\" in entry.index:\n        return f\"{entry['filename']}\"\n    elif \"FCG\" in entry.index:\n        return f\"{entry['FCG']}\"\n    else:\n        raise _NoValidCelestialCoordinatesError()\n\n    return f\"{ra}{format_dec(dec)}\"\n</code></pre>"},{"location":"modules/#rgc.utils.data.compute_mean_std","title":"<code>compute_mean_std(dataloader)</code>","text":"<p>Compute the mean and standard deviation of the dataset.</p> <p>:param dataloader: The dataloader for the dataset. :type dataloader: torch.utils.data.DataLoader</p> <p>:return: The mean and standard deviation of the dataset. :rtype: tuple[torch.Tensor, torch.Tensor]</p> Source code in <code>rgc/utils/data.py</code> <pre><code>def compute_mean_std(dataloader: torch.utils.data.DataLoader) -&gt; tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Compute the mean and standard deviation of the dataset.\n\n    :param dataloader: The dataloader for the dataset.\n    :type dataloader: torch.utils.data.DataLoader\n\n    :return: The mean and standard deviation of the dataset.\n    :rtype: tuple[torch.Tensor, torch.Tensor]\n    \"\"\"\n    data = torch.tensor([])\n    for batch in dataloader:\n        data = torch.cat((data, batch[0]), 0)\n\n    mean = torch.mean(data, dim=(0, 2, 3))\n    std = torch.std(data, dim=(0, 2, 3))\n\n    return mean, std\n</code></pre>"},{"location":"modules/#rgc.utils.data.dataframe_to_html","title":"<code>dataframe_to_html(catalog, save_dir)</code>","text":"<p>Save the catalog as an HTML file.</p> <p>:param catalog: Catalog of the astronomical objects :type catalog: pd.DataFrame :param save_dir: Path to the directory to save the HTML file :type save_dir: str</p> Source code in <code>rgc/utils/data.py</code> <pre><code>def dataframe_to_html(catalog: pd.DataFrame, save_dir: str) -&gt; None:\n    \"\"\"\n    Save the catalog as an HTML file.\n\n    :param catalog: Catalog of the astronomical objects\n    :type catalog: pd.DataFrame\n    :param save_dir: Path to the directory to save the HTML file\n    :type save_dir: str\n    \"\"\"\n    Path(save_dir).mkdir(parents=True, exist_ok=True)\n    catalog.to_html(os.path.join(save_dir, \"catalog.html\"))\n</code></pre>"},{"location":"modules/#rgc.utils.data.fits_to_png","title":"<code>fits_to_png(fits_file, img_size=None)</code>","text":"<p>Convert a FITS file to a PNG image.</p> <p>:param fits_file: The path to the FITS file. :type fits_file: str</p> <p>:param img_size: The size of the output image. :type img_size: Optional[tuple[int, int]]</p> <p>:return: A PIL Image object containing the PNG image. :rtype: Image.Image</p> <p>:raises _FileNotFoundError: If the FITS file is not found.</p> Source code in <code>rgc/utils/data.py</code> <pre><code>def fits_to_png(fits_file: str, img_size: Optional[tuple[int, int]] = None) -&gt; Image.Image:\n    \"\"\"\n    Convert a FITS file to a PNG image.\n\n    :param fits_file: The path to the FITS file.\n    :type fits_file: str\n\n    :param img_size: The size of the output image.\n    :type img_size: Optional[tuple[int, int]]\n\n    :return: A PIL Image object containing the PNG image.\n    :rtype: Image.Image\n\n    :raises _FileNotFoundError: If the FITS file is not found.\n    \"\"\"\n    try:\n        image = fits.getdata(fits_file)\n        header = fits.getheader(fits_file)\n    except FileNotFoundError as err:\n        raise _FileNotFoundError(fits_file) from err\n\n    if img_size is not None:\n        width, height = img_size\n    else:\n        width, height = header[\"NAXIS1\"], header[\"NAXIS2\"]\n\n    image = np.reshape(image, (height, width))\n    image[np.isnan(image)] = np.nanmin(image)\n\n    image = (image - np.nanmin(image)) / (np.nanmax(image) - np.nanmin(image)) * 255\n    image = image.astype(np.uint8)\n    image = Image.fromarray(image, mode=\"L\")\n\n    return cast(Image.Image, image)\n</code></pre>"},{"location":"modules/#rgc.utils.data.fits_to_png_bulk","title":"<code>fits_to_png_bulk(fits_dir, png_dir, img_size=None)</code>","text":"<p>Convert a directory of FITS files to PNG images.</p> <p>:param fits_dir: The path to the directory containing the FITS files. :type fits_dir: str</p> <p>:param png_dir: The path to the directory to save the PNG images. :type png_dir: str</p> <p>:param img_size: The size of the output image. :type img_size: Optional[tuple[int, int]]</p> Source code in <code>rgc/utils/data.py</code> <pre><code>def fits_to_png_bulk(fits_dir: str, png_dir: str, img_size: Optional[tuple[int, int]] = None) -&gt; None:\n    \"\"\"\n    Convert a directory of FITS files to PNG images.\n\n    :param fits_dir: The path to the directory containing the FITS files.\n    :type fits_dir: str\n\n    :param png_dir: The path to the directory to save the PNG images.\n    :type png_dir: str\n\n    :param img_size: The size of the output image.\n    :type img_size: Optional[tuple[int, int]]\n    \"\"\"\n    fits_files = Path(fits_dir).rglob(\"*.fits\")\n    for fits_file in fits_files:\n        image = fits_to_png(str(fits_file), img_size)\n\n        png_file = os.path.join(png_dir, fits_file.stem)\n        Path(png_file).parent.mkdir(parents=True, exist_ok=True)\n\n        if image is not None:\n            image.save(png_file)\n</code></pre>"},{"location":"modules/#rgc.utils.data.mask_image","title":"<code>mask_image(image, mask)</code>","text":"<p>Mask an image with a given mask image.</p> <p>:param image: The image to be masked. :type image: Image.Image</p> <p>:param mask: The mask image. :type mask: Image.Image</p> <p>:return: A PIL Image object containing the masked image. :rtype: Image.Image</p> <p>:raises _ImageMaskDimensionError: If the dimensions of the image and mask do not match.</p> Source code in <code>rgc/utils/data.py</code> <pre><code>def mask_image(image: Image.Image, mask: Image.Image) -&gt; Image.Image:\n    \"\"\"\n    Mask an image with a given mask image.\n\n    :param image: The image to be masked.\n    :type image: Image.Image\n\n    :param mask: The mask image.\n    :type mask: Image.Image\n\n    :return: A PIL Image object containing the masked image.\n    :rtype: Image.Image\n\n    :raises _ImageMaskDimensionError: If the dimensions of the image and mask do not match.\n    \"\"\"\n    image_array = np.array(image)\n    mask_array = np.array(mask)\n\n    if image_array.shape != mask_array.shape:\n        raise _ImageMaskDimensionError()\n\n    masked_array = np.where(mask_array == 0, 0, image_array)\n    masked_image = Image.fromarray(masked_array, mode=\"L\")\n\n    return cast(Image.Image, masked_image)\n</code></pre>"},{"location":"modules/#rgc.utils.data.mask_image_bulk","title":"<code>mask_image_bulk(image_dir, mask_dir, masked_dir)</code>","text":"<p>Mask a directory of images with a directory of mask images.</p> <p>:param image_dir: The path to the directory containing the images. :type image_dir: str</p> <p>:param mask_dir: The path to the directory containing the mask images. :type mask_dir: str</p> <p>:param masked_dir: The path to the directory to save the masked images. :type masked_dir: str</p> <p>:raises _FileNotFoundError: If no images or masks are found in the directories. :raises _ImageMaskCountMismatchError: If the number of images and masks do not match.</p> Source code in <code>rgc/utils/data.py</code> <pre><code>def mask_image_bulk(image_dir: str, mask_dir: str, masked_dir: str) -&gt; None:\n    \"\"\"\n    Mask a directory of images with a directory of mask images.\n\n    :param image_dir: The path to the directory containing the images.\n    :type image_dir: str\n\n    :param mask_dir: The path to the directory containing the mask images.\n    :type mask_dir: str\n\n    :param masked_dir: The path to the directory to save the masked images.\n    :type masked_dir: str\n\n    :raises _FileNotFoundError: If no images or masks are found in the directories.\n    :raises _ImageMaskCountMismatchError: If the number of images and masks do not match.\n    \"\"\"\n    image_paths = sorted(Path(image_dir).glob(\"*.png\"))\n    mask_paths = sorted(Path(mask_dir).glob(\"*.png\"))\n\n    if len(image_paths) == 0 or len(mask_paths) == 0:\n        raise _FileNotFoundError()\n\n    if len(image_paths) != len(mask_paths):\n        raise _ImageMaskCountMismatchError() from None\n\n    os.makedirs(masked_dir, exist_ok=True)\n\n    for image_path in image_paths:\n        mask_path = Path(mask_dir) / image_path.name\n\n        if not mask_path.exists():\n            print(f\"Skipping {image_path.name} due to missing mask.\")\n            continue\n\n        image = Image.open(image_path)\n        mask = Image.open(mask_path)\n\n        if image.size != mask.size:\n            print(f\"Skipping {image_path.name} due to mismatched dimensions.\")\n            continue\n        else:\n            masked_image = mask_image(image, mask)\n\n        masked_image.save(Path(masked_dir) / image_path.name)\n</code></pre>"},{"location":"modules/#rgc.utils.data.remove_artifacts","title":"<code>remove_artifacts(folder, extension)</code>","text":"<p>Remove files with the given extensions from a folder.</p> <p>:param folder: Path to the folder to clear :type folder: str :param extension: List of file with the given extensions to keep :type extension: list</p> Source code in <code>rgc/utils/data.py</code> <pre><code>def remove_artifacts(folder: str, extension: list[str]) -&gt; None:\n    \"\"\"\n    Remove files with the given extensions from a folder.\n\n    :param folder: Path to the folder to clear\n    :type folder: str\n    :param extension: List of file with the given extensions to keep\n    :type extension: list\n    \"\"\"\n    for file in os.listdir(folder):\n        if not file.endswith(tuple(extension)):\n            os.remove(os.path.join(folder, file))\n\n    print(f\"Artifacts removed from {folder} with extensions {', '.join(extension)}\")\n</code></pre>"}]}